{"ast":null,"code":"var _jsxFileName = \"/home/jerv/code_projects/data_playground/webapp/src/hooks/useCollection.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { useState, createContext, useContext, useCallback } from 'react';\nimport { toast } from 'react-hot-toast';\nimport { collectionsAPI } from '../services/api';\n\n// Initial collection state\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst initialState = {\n  collections: [],\n  currentCollection: null,\n  isLoading: false,\n  error: null\n};\n\n// Create context\nexport const CollectionContext = /*#__PURE__*/createContext({\n  collectionState: initialState,\n  fetchCollections: async () => {},\n  fetchCollection: async () => {},\n  createCollection: async () => {},\n  updateCollection: async () => {},\n  deleteCollection: async () => {},\n  addEntry: async () => {},\n  updateEntry: async () => {},\n  deleteEntry: async () => {}\n});\n\n// Collection provider component\nexport const CollectionProvider = ({\n  children\n}) => {\n  _s();\n  const [collectionState, setCollectionState] = useState(initialState);\n\n  // Fetch all collections\n  const fetchCollections = useCallback(async () => {\n    try {\n      setCollectionState(prev => ({\n        ...prev,\n        isLoading: true\n      }));\n      const {\n        collections\n      } = await collectionsAPI.getCollections();\n      setCollectionState(prev => ({\n        ...prev,\n        collections,\n        isLoading: false,\n        error: null\n      }));\n    } catch (error) {\n      var _error$response, _error$response$data;\n      const errorMessage = ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || 'Failed to fetch collections';\n      setCollectionState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: errorMessage\n      }));\n      toast.error(errorMessage);\n    }\n  }, []);\n\n  // Fetch a single collection\n  const fetchCollection = useCallback(async id => {\n    try {\n      setCollectionState(prev => ({\n        ...prev,\n        isLoading: true\n      }));\n      const {\n        collection\n      } = await collectionsAPI.getCollection(id);\n      setCollectionState(prev => ({\n        ...prev,\n        currentCollection: collection,\n        isLoading: false,\n        error: null\n      }));\n    } catch (error) {\n      var _error$response2, _error$response2$data;\n      const errorMessage = ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || 'Failed to fetch collection';\n      setCollectionState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: errorMessage\n      }));\n      toast.error(errorMessage);\n    }\n  }, []);\n\n  // Create a new collection\n  const createCollection = useCallback(async data => {\n    try {\n      setCollectionState(prev => ({\n        ...prev,\n        isLoading: true\n      }));\n      const {\n        collection\n      } = await collectionsAPI.createCollection(data);\n      setCollectionState(prev => ({\n        ...prev,\n        collections: [...prev.collections, collection],\n        isLoading: false,\n        error: null\n      }));\n      toast.success('Collection created successfully');\n    } catch (error) {\n      var _error$response3, _error$response3$data;\n      const errorMessage = ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.message) || 'Failed to create collection';\n      setCollectionState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: errorMessage\n      }));\n      toast.error(errorMessage);\n    }\n  }, []);\n\n  // Update a collection\n  const updateCollection = useCallback(async (id, data) => {\n    try {\n      setCollectionState(prev => ({\n        ...prev,\n        isLoading: true\n      }));\n      const {\n        collection\n      } = await collectionsAPI.updateCollection(id, data);\n      setCollectionState(prev => {\n        // Update collections array\n        const updatedCollections = prev.collections.map(c => c.id === id ? collection : c);\n        return {\n          ...prev,\n          collections: updatedCollections,\n          currentCollection: collection,\n          isLoading: false,\n          error: null\n        };\n      });\n      toast.success('Collection updated successfully');\n    } catch (error) {\n      var _error$response4, _error$response4$data;\n      const errorMessage = ((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : (_error$response4$data = _error$response4.data) === null || _error$response4$data === void 0 ? void 0 : _error$response4$data.message) || 'Failed to update collection';\n      setCollectionState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: errorMessage\n      }));\n      toast.error(errorMessage);\n    }\n  }, []);\n\n  // Delete a collection\n  const deleteCollection = async id => {\n    try {\n      setCollectionState(prev => ({\n        ...prev,\n        isLoading: true\n      }));\n      await collectionsAPI.deleteCollection(id);\n\n      // Remove collection from state\n      const updatedCollections = collectionState.collections.filter(c => c.id !== id);\n      setCollectionState({\n        ...collectionState,\n        collections: updatedCollections,\n        currentCollection: null,\n        isLoading: false,\n        error: null\n      });\n      toast.success('Collection deleted successfully');\n    } catch (error) {\n      var _error$response5, _error$response5$data;\n      const errorMessage = ((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : (_error$response5$data = _error$response5.data) === null || _error$response5$data === void 0 ? void 0 : _error$response5$data.message) || 'Failed to delete collection';\n      setCollectionState({\n        ...collectionState,\n        isLoading: false,\n        error: errorMessage\n      });\n      toast.error(errorMessage);\n    }\n  };\n\n  // Add an entry to a collection\n  const addEntry = async (collectionId, entry) => {\n    try {\n      setCollectionState(prev => ({\n        ...prev,\n        isLoading: true\n      }));\n      const {\n        entry: newEntry\n      } = await collectionsAPI.addEntry(collectionId, entry);\n\n      // Update current collection if it's the one being modified\n      if (collectionState.currentCollection && collectionState.currentCollection.id === collectionId) {\n        const updatedCollection = {\n          ...collectionState.currentCollection,\n          entries: [...(collectionState.currentCollection.entries || []), newEntry]\n        };\n        setCollectionState({\n          ...collectionState,\n          currentCollection: updatedCollection,\n          isLoading: false,\n          error: null\n        });\n      }\n      toast.success('Entry added successfully');\n    } catch (error) {\n      var _error$response6, _error$response6$data;\n      const errorMessage = ((_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : (_error$response6$data = _error$response6.data) === null || _error$response6$data === void 0 ? void 0 : _error$response6$data.message) || 'Failed to add entry';\n      setCollectionState({\n        ...collectionState,\n        isLoading: false,\n        error: errorMessage\n      });\n      toast.error(errorMessage);\n    }\n  };\n\n  // Update an entry in a collection\n  const updateEntry = async (collectionId, entryIndex, entry) => {\n    try {\n      setCollectionState(prev => ({\n        ...prev,\n        isLoading: true\n      }));\n      const {\n        entry: updatedEntry\n      } = await collectionsAPI.updateEntry(collectionId, entryIndex, entry);\n\n      // Update current collection if it's the one being modified\n      if (collectionState.currentCollection && collectionState.currentCollection.id === collectionId) {\n        const updatedEntries = [...(collectionState.currentCollection.entries || [])];\n        updatedEntries[entryIndex] = updatedEntry;\n        const updatedCollection = {\n          ...collectionState.currentCollection,\n          entries: updatedEntries\n        };\n        setCollectionState({\n          ...collectionState,\n          currentCollection: updatedCollection,\n          isLoading: false,\n          error: null\n        });\n      }\n      toast.success('Entry updated successfully');\n    } catch (error) {\n      var _error$response7, _error$response7$data;\n      const errorMessage = ((_error$response7 = error.response) === null || _error$response7 === void 0 ? void 0 : (_error$response7$data = _error$response7.data) === null || _error$response7$data === void 0 ? void 0 : _error$response7$data.message) || 'Failed to update entry';\n      setCollectionState({\n        ...collectionState,\n        isLoading: false,\n        error: errorMessage\n      });\n      toast.error(errorMessage);\n    }\n  };\n\n  // Delete an entry from a collection\n  const deleteEntry = async (collectionId, entryIndex) => {\n    try {\n      setCollectionState(prev => ({\n        ...prev,\n        isLoading: true\n      }));\n      await collectionsAPI.deleteEntry(collectionId, entryIndex);\n\n      // Update current collection if it's the one being modified\n      if (collectionState.currentCollection && collectionState.currentCollection.id === collectionId) {\n        const updatedEntries = [...(collectionState.currentCollection.entries || [])];\n        updatedEntries.splice(entryIndex, 1);\n        const updatedCollection = {\n          ...collectionState.currentCollection,\n          entries: updatedEntries\n        };\n        setCollectionState({\n          ...collectionState,\n          currentCollection: updatedCollection,\n          isLoading: false,\n          error: null\n        });\n      }\n      toast.success('Entry deleted successfully');\n    } catch (error) {\n      var _error$response8, _error$response8$data;\n      const errorMessage = ((_error$response8 = error.response) === null || _error$response8 === void 0 ? void 0 : (_error$response8$data = _error$response8.data) === null || _error$response8$data === void 0 ? void 0 : _error$response8$data.message) || 'Failed to delete entry';\n      setCollectionState({\n        ...collectionState,\n        isLoading: false,\n        error: errorMessage\n      });\n      toast.error(errorMessage);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(CollectionContext.Provider, {\n    value: {\n      collectionState,\n      fetchCollections,\n      fetchCollection,\n      createCollection,\n      updateCollection,\n      deleteCollection,\n      addEntry,\n      updateEntry,\n      deleteEntry\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 276,\n    columnNumber: 5\n  }, this);\n};\n\n// Custom hook to use collection context\n_s(CollectionProvider, \"dCdzPBFNI5qIpIBd0hxxK0eFdPw=\");\n_c = CollectionProvider;\nexport const useCollection = () => {\n  _s2();\n  const context = useContext(CollectionContext);\n  if (!context) {\n    throw new Error('useCollection must be used within a CollectionProvider');\n  }\n  return context;\n};\n_s2(useCollection, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"CollectionProvider\");","map":{"version":3,"names":["React","useState","createContext","useContext","useCallback","toast","collectionsAPI","jsxDEV","_jsxDEV","initialState","collections","currentCollection","isLoading","error","CollectionContext","collectionState","fetchCollections","fetchCollection","createCollection","updateCollection","deleteCollection","addEntry","updateEntry","deleteEntry","CollectionProvider","children","_s","setCollectionState","prev","getCollections","_error$response","_error$response$data","errorMessage","response","data","message","id","collection","getCollection","_error$response2","_error$response2$data","success","_error$response3","_error$response3$data","updatedCollections","map","c","_error$response4","_error$response4$data","filter","_error$response5","_error$response5$data","collectionId","entry","newEntry","updatedCollection","entries","_error$response6","_error$response6$data","entryIndex","updatedEntry","updatedEntries","_error$response7","_error$response7$data","splice","_error$response8","_error$response8$data","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useCollection","_s2","context","Error","$RefreshReg$"],"sources":["/home/jerv/code_projects/data_playground/webapp/src/hooks/useCollection.tsx"],"sourcesContent":["import React, { useState, useEffect, createContext, useContext, useCallback } from 'react';\nimport { toast } from 'react-hot-toast';\nimport { Collection, CollectionFormData, Entry, CollectionState } from '../types/collection';\nimport { collectionsAPI } from '../services/api';\n\n// Initial collection state\nconst initialState: CollectionState = {\n  collections: [],\n  currentCollection: null,\n  isLoading: false,\n  error: null,\n};\n\n// Create context\nexport const CollectionContext = createContext<{\n  collectionState: CollectionState;\n  fetchCollections: () => Promise<void>;\n  fetchCollection: (id: string) => Promise<void>;\n  createCollection: (data: CollectionFormData) => Promise<void>;\n  updateCollection: (id: string, data: CollectionFormData) => Promise<void>;\n  deleteCollection: (id: string) => Promise<void>;\n  addEntry: (collectionId: string, entry: Entry) => Promise<void>;\n  updateEntry: (collectionId: string, entryIndex: number, entry: Entry) => Promise<void>;\n  deleteEntry: (collectionId: string, entryIndex: number) => Promise<void>;\n}>({\n  collectionState: initialState,\n  fetchCollections: async () => {},\n  fetchCollection: async () => {},\n  createCollection: async () => {},\n  updateCollection: async () => {},\n  deleteCollection: async () => {},\n  addEntry: async () => {},\n  updateEntry: async () => {},\n  deleteEntry: async () => {},\n});\n\n// Collection provider component\nexport const CollectionProvider = ({ children }: { children: React.ReactNode }) => {\n  const [collectionState, setCollectionState] = useState<CollectionState>(initialState);\n\n  // Fetch all collections\n  const fetchCollections = useCallback(async () => {\n    try {\n      setCollectionState(prev => ({ ...prev, isLoading: true }));\n      const { collections } = await collectionsAPI.getCollections();\n      setCollectionState(prev => ({\n        ...prev,\n        collections,\n        isLoading: false,\n        error: null,\n      }));\n    } catch (error: any) {\n      const errorMessage = error.response?.data?.message || 'Failed to fetch collections';\n      setCollectionState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: errorMessage,\n      }));\n      toast.error(errorMessage);\n    }\n  }, []);\n\n  // Fetch a single collection\n  const fetchCollection = useCallback(async (id: string) => {\n    try {\n      setCollectionState(prev => ({ ...prev, isLoading: true }));\n      const { collection } = await collectionsAPI.getCollection(id);\n      setCollectionState(prev => ({\n        ...prev,\n        currentCollection: collection,\n        isLoading: false,\n        error: null,\n      }));\n    } catch (error: any) {\n      const errorMessage = error.response?.data?.message || 'Failed to fetch collection';\n      setCollectionState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: errorMessage,\n      }));\n      toast.error(errorMessage);\n    }\n  }, []);\n\n  // Create a new collection\n  const createCollection = useCallback(async (data: CollectionFormData) => {\n    try {\n      setCollectionState(prev => ({ ...prev, isLoading: true }));\n      const { collection } = await collectionsAPI.createCollection(data);\n      setCollectionState(prev => ({\n        ...prev,\n        collections: [...prev.collections, collection],\n        isLoading: false,\n        error: null,\n      }));\n      toast.success('Collection created successfully');\n    } catch (error: any) {\n      const errorMessage = error.response?.data?.message || 'Failed to create collection';\n      setCollectionState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: errorMessage,\n      }));\n      toast.error(errorMessage);\n    }\n  }, []);\n\n  // Update a collection\n  const updateCollection = useCallback(async (id: string, data: CollectionFormData) => {\n    try {\n      setCollectionState(prev => ({ ...prev, isLoading: true }));\n      const { collection } = await collectionsAPI.updateCollection(id, data);\n      \n      setCollectionState(prev => {\n        // Update collections array\n        const updatedCollections = prev.collections.map(c => \n          c.id === id ? collection : c\n        );\n        \n        return {\n          ...prev,\n          collections: updatedCollections,\n          currentCollection: collection,\n          isLoading: false,\n          error: null,\n        };\n      });\n      \n      toast.success('Collection updated successfully');\n    } catch (error: any) {\n      const errorMessage = error.response?.data?.message || 'Failed to update collection';\n      setCollectionState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: errorMessage,\n      }));\n      toast.error(errorMessage);\n    }\n  }, []);\n\n  // Delete a collection\n  const deleteCollection = async (id: string) => {\n    try {\n      setCollectionState(prev => ({ ...prev, isLoading: true }));\n      await collectionsAPI.deleteCollection(id);\n      \n      // Remove collection from state\n      const updatedCollections = collectionState.collections.filter(c => c.id !== id);\n      \n      setCollectionState({\n        ...collectionState,\n        collections: updatedCollections,\n        currentCollection: null,\n        isLoading: false,\n        error: null,\n      });\n      \n      toast.success('Collection deleted successfully');\n    } catch (error: any) {\n      const errorMessage = error.response?.data?.message || 'Failed to delete collection';\n      setCollectionState({\n        ...collectionState,\n        isLoading: false,\n        error: errorMessage,\n      });\n      toast.error(errorMessage);\n    }\n  };\n\n  // Add an entry to a collection\n  const addEntry = async (collectionId: string, entry: Entry) => {\n    try {\n      setCollectionState(prev => ({ ...prev, isLoading: true }));\n      const { entry: newEntry } = await collectionsAPI.addEntry(collectionId, entry);\n      \n      // Update current collection if it's the one being modified\n      if (collectionState.currentCollection && collectionState.currentCollection.id === collectionId) {\n        const updatedCollection = {\n          ...collectionState.currentCollection,\n          entries: [...(collectionState.currentCollection.entries || []), newEntry],\n        };\n        \n        setCollectionState({\n          ...collectionState,\n          currentCollection: updatedCollection,\n          isLoading: false,\n          error: null,\n        });\n      }\n      \n      toast.success('Entry added successfully');\n    } catch (error: any) {\n      const errorMessage = error.response?.data?.message || 'Failed to add entry';\n      setCollectionState({\n        ...collectionState,\n        isLoading: false,\n        error: errorMessage,\n      });\n      toast.error(errorMessage);\n    }\n  };\n\n  // Update an entry in a collection\n  const updateEntry = async (collectionId: string, entryIndex: number, entry: Entry) => {\n    try {\n      setCollectionState(prev => ({ ...prev, isLoading: true }));\n      const { entry: updatedEntry } = await collectionsAPI.updateEntry(collectionId, entryIndex, entry);\n      \n      // Update current collection if it's the one being modified\n      if (collectionState.currentCollection && collectionState.currentCollection.id === collectionId) {\n        const updatedEntries = [...(collectionState.currentCollection.entries || [])];\n        updatedEntries[entryIndex] = updatedEntry;\n        \n        const updatedCollection = {\n          ...collectionState.currentCollection,\n          entries: updatedEntries,\n        };\n        \n        setCollectionState({\n          ...collectionState,\n          currentCollection: updatedCollection,\n          isLoading: false,\n          error: null,\n        });\n      }\n      \n      toast.success('Entry updated successfully');\n    } catch (error: any) {\n      const errorMessage = error.response?.data?.message || 'Failed to update entry';\n      setCollectionState({\n        ...collectionState,\n        isLoading: false,\n        error: errorMessage,\n      });\n      toast.error(errorMessage);\n    }\n  };\n\n  // Delete an entry from a collection\n  const deleteEntry = async (collectionId: string, entryIndex: number) => {\n    try {\n      setCollectionState(prev => ({ ...prev, isLoading: true }));\n      await collectionsAPI.deleteEntry(collectionId, entryIndex);\n      \n      // Update current collection if it's the one being modified\n      if (collectionState.currentCollection && collectionState.currentCollection.id === collectionId) {\n        const updatedEntries = [...(collectionState.currentCollection.entries || [])];\n        updatedEntries.splice(entryIndex, 1);\n        \n        const updatedCollection = {\n          ...collectionState.currentCollection,\n          entries: updatedEntries,\n        };\n        \n        setCollectionState({\n          ...collectionState,\n          currentCollection: updatedCollection,\n          isLoading: false,\n          error: null,\n        });\n      }\n      \n      toast.success('Entry deleted successfully');\n    } catch (error: any) {\n      const errorMessage = error.response?.data?.message || 'Failed to delete entry';\n      setCollectionState({\n        ...collectionState,\n        isLoading: false,\n        error: errorMessage,\n      });\n      toast.error(errorMessage);\n    }\n  };\n\n  return (\n    <CollectionContext.Provider \n      value={{ \n        collectionState, \n        fetchCollections, \n        fetchCollection, \n        createCollection, \n        updateCollection, \n        deleteCollection, \n        addEntry, \n        updateEntry, \n        deleteEntry \n      }}\n    >\n      {children}\n    </CollectionContext.Provider>\n  );\n};\n\n// Custom hook to use collection context\nexport const useCollection = () => {\n  const context = useContext(CollectionContext);\n  \n  if (!context) {\n    throw new Error('useCollection must be used within a CollectionProvider');\n  }\n  \n  return context;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}